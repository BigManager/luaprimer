# 环境与模块

## (1) 全局变量与环境

lua 中真正存储全局变量的地方不是在 \_G 里面，而是在setfenv（i,table）的table中，所有当前的全局变量都在这里面找，只不过在程序开始时lua会默认先设置一个变量 \_G= 这个里面的table而已。所以在新设置环境后，如果还想找到之前的全局变量，通常需要附加上为新的table设置元表{\_index=\_G}

下面的几个例子：

	a=1
	print(a)
	print(_G.a)
	--正常情况，输出1,1

	a=1
	setfenv(1,{})
	print(a)
	print(_G.a)
	--这时会出错说找不到print，因为当前的全局变量表示空的，啥也找不到的

	a=1
	setfenv(1,{_G=_G})
	_G.print(_G.a)
	
	print(a)
	--这时_G.print(_G.a)可以正常吗，因为可以在新的table中找到一个叫_G的表，这个_G有之前的奈尔全局变量，但是下面的print(a)则找不到print，因为当前的table{_G=_G}没有一个叫print的东西

	local mt={__index=_G}
	local t={}
	setmetatable(t,mt)
	setfenv(1,t)
	print(a)
	print(_G.a)
	--这是正确输出，因为新的全局表采用之前的表做找不到时的索引，原先的表里面存在print 、_G、 a这些东西

**setfenv的第一个参数可以是当前的堆栈层次，如1代表当前代码块，2表调用当前的上一层，也可以是具体的那个函数名，表示在那个函数里。**

每个新创建的函数都将继承创建它的那个函数的全局环境。

### (2) require

require 的意义就是导入一堆可用的名称，这些名称（非local的）都包含在一个table中，这个table再被包含在当前的全局表（“通常的那个_G”）中，这样访问一个模块中的变量就可以使用_G.table.**了，初学者可能会认为模块里的名称在导入后直接就是在 _G 中了。

	m=require module 

的 m 取决于这个导入的文件的返回值，没有返回值时true，所以在标准的情况下模块的结尾应该 return 这个模块的名字，这样 m 就是这个模块的table了。

## 导航
* [目录](00.md)
* 上一章：[Lua 基础知识](01.md)
* 下一章：[函数与面向对象](03.md)